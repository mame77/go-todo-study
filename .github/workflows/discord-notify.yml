name: Notify Discord

on:
  issues:
    types: [opened, assigned]           # Issueä½œæˆ/ã‚¢ã‚µã‚¤ãƒ³å¤‰æ›´
  pull_request:
    types: [opened, review_requested, ready_for_review, closed, reopened] # PRä½œæˆ/ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¾é ¼/ãƒãƒ¼ã‚¸ç­‰
  pull_request_review:
    types: [submitted]                   # ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ°ç€

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  notify-discord:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Notify
        uses: actions/github-script@v7
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        with:
          script: |
            const fs = require('fs');

            // --- å…±é€š: ãƒãƒƒãƒ—èª­è¾¼ã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---
            let map = {};
            try {
              map = JSON.parse(fs.readFileSync('.github/discord-map.json', 'utf8'));
            } catch (e) {
              core.warning('discord-map.json ãŒèª­ã‚ã¾ã›ã‚“ã€‚ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãªã—ã§é€ã‚Šã¾ã™ã€‚');
            }

            const mentionOf = (login) => {
              const id = map[login];
              return id ? `<@${id}>` : `@${login}`;
            };

            const uniq = (arr) => [...new Set(arr)].filter(Boolean);

            const post = async (content) => {
              const url = process.env.DISCORD_WEBHOOK_URL;
              if (!url) throw new Error('DISCORD_WEBHOOK_URL ãŒæœªè¨­å®šã§ã™');
              const body = { content };
              const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
              });
              if (!res.ok) {
                core.setFailed(`Discordé€ä¿¡å¤±æ•—: ${res.status} ${await res.text()}`);
              }
            };

            const ev = context.eventName;
            const action = context.payload.action;

            // ---- ã‚±ãƒ¼ã‚¹åˆ†å² ----
            if (ev === 'issues') {
              // ä»•æ§˜: Issueã‚’ç«‹ã¦ãŸæ™‚ã« assign ã—ãŸäººã¸ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³
              // å¯¾è±¡: openedï¼ˆåˆå›ã«assigneesãŒä»˜ã„ã¦ã„ã‚‹å ´åˆï¼‰ã¨ assignedï¼ˆå¾Œã‹ã‚‰ä»˜ä¸ï¼‰
              if (action === 'opened' || action === 'assigned') {
                const issue = context.payload.issue;
                const repo = context.repo.repo;
                const owner = context.repo.owner;
                const url = issue.html_url;

                const assignees = (issue.assignees || []).map(a => a.login);
                if (assignees.length === 0) {
                  return; // ã‚¢ã‚µã‚¤ãƒ³ç„¡ã—ãªã‚‰ä½•ã‚‚ã—ãªã„
                }

                const mentions = uniq(assignees).map(mentionOf).join(' ');
                const title = issue.title;

                const msg = [
                  `ğŸ“ **Issue Assigned** in \`${owner}/${repo}\``,
                  `**${title}**`,
                  `${mentions}`,
                  `${url}`
                ].join('\n');

                await post(msg);
              }
            }

            else if (ev === 'pull_request') {
              const pr = context.payload.pull_request;
              const owner = context.repo.owner;
              const repo = context.repo.repo;

              if (action === 'review_requested') {
                // ä»•æ§˜: PRã‚’ç«‹ã¦ãŸæ™‚ã« reviewer ã«ã—ãŸäººã¸ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³
                // â€»ã€Œreview_requestedã€ã¯ä½œæˆæ™‚ï¼å¾Œã‹ã‚‰ä¾é ¼ã—ãŸæ™‚ã©ã¡ã‚‰ã‚‚ç™ºç«
                const reqReviewer = context.payload.requested_reviewer?.login;
                const reqTeam = context.payload.requested_team?.name;
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼å€‹åˆ¥ã®ã¿ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ï¼ˆãƒãƒ¼ãƒ ã¯ä»»æ„ã§ãƒ­ãƒ¼ãƒ«ã«ç½®æ›ã—ã¦ã‚‚OKï¼‰
                if (reqReviewer) {
                  const msg = [
                    `ğŸ‘€ **Review Requested** in \`${owner}/${repo}\``,
                    `**${pr.title}** by @${pr.user.login}`,
                    `${mentionOf(reqReviewer)}`,
                    `${pr.html_url}`
                  ].join('\n');
                  await post(msg);
                }
              }

              else if (action === 'opened' || action === 'ready_for_review' || action === 'reopened') {
                // PRä½œæˆæ™‚ï¼Draftè§£é™¤æ™‚: reviewerãŒåŒæ™‚æŒ‡å®šã•ã‚Œã¦ã„ãŸã‚‰é€šçŸ¥ï¼ˆä»»æ„ï¼‰
                const reviewers = (pr.requested_reviewers || []).map(u => u.login);
                if (reviewers.length > 0) {
                  const msg = [
                    `ğŸ†• **PR Opened** in \`${owner}/${repo}\``,
                    `**${pr.title}** by @${pr.user.login}`,
                    `Reviewers: ${uniq(reviewers).map(mentionOf).join(' ')}`,
                    `${pr.html_url}`
                  ].join('\n');
                  await post(msg);
                }
              }

              else if (action === 'closed' && pr.merged) {
                // ä»•æ§˜: PRãŒmergeã•ã‚ŒãŸã¨ãã«é€šçŸ¥
                const msg = [
                  `âœ… **PR Merged** in \`${owner}/${repo}\``,
                  `**${pr.title}** by @${pr.user.login}`,
                  `${pr.html_url}`
                ].join('\n');
                await post(msg);
              }
            }

            else if (ev === 'pull_request_review') {
              // ä»•æ§˜: PRã«reviewãŒæ¥ãŸã¨ãã«é€šçŸ¥
              if (action === 'submitted') {
                const pr = context.payload.pull_request;
                const review = context.payload.review;
                const owner = context.repo.owner;
                const repo = context.repo.repo;

                const state = (review.state || '').toUpperCase(); // APPROVED / CHANGES_REQUESTED / COMMENTED
                const reviewer = review.user?.login;
                const msg = [
                  `ğŸ’¬ **PR Review (${state})** in \`${owner}/${repo}\``,
                  `**${pr.title}**`,
                  `Reviewer: ${reviewer ? mentionOf(reviewer) : '(unknown)'}`,
                  `${pr.html_url}#pullrequestreview-${review.id}`
                ].join('\n');

                await post(msg);
              }
            }

            // push ã¯ãƒˆãƒªã‚¬ãƒ¼ã—ã¦ã„ãªã„ï¼ˆä»•æ§˜é€šã‚Šé€šçŸ¥ã—ãªã„ï¼‰
